二叉树是一种遵守以下规则的树

- 每个节点的子节点数量可为 0、1、2
- 如果有两个子节点，则其中一个子节点的值必须小于父节点，另一个子节点的值必须大于父节点。



## 删除

删除需要遵循以下规则

- 如果要删除的节点没有子节点，直接删掉就好
- 如果要删除的节点有一个子节点，那么删掉它之后，还要将子节点填到原本被删除的节点位置上
- 如果要删除的节点有两个节点，则将该节点替换成其**后继节点**，**一个节点的后继节点，就是所有比被删除节点大的子节点中，最小的那个**。
  - 如果后继节点带有右子节点，则在后继节点填补被删除的节点以后，用此右子节点替代后继节点的父节点的左子节点。





# 图

有向图和无向图

图的遍历

## 广度优先搜索(使用队列遍历)

- 找出当前顶点的所有邻结点。如果有哪个是没有访问过的，就把它标为 "已访问"，并且将它入队。
- 如果当前订单没有未访问过的邻结点，且队列不为空，那就再从队列中移出一个顶点作为当前顶点。
- 如果当前顶点没有未访问的邻结点，且队列里也没有其他的顶点，那么算法完成。



图的广度优先搜索可以大致上分为两步：

1. 让顶点出队，将其设置成当前顶点
2. 访问每个顶点的邻结点

那么如果有 V 个顶点，就会存在 V 次出队。访问一个结点的邻结点，处理两次边。以 A-B-C 为例，当我们处理 A 时，发现 B 是 A 的邻结点；当我们处理 B 时，发现 A 是 B 的邻结点（尽管 A 曾被访问过，不用再入队），A 和 B 之间只存在一条边，但是每条边连接着两个结点，所以每条边都会被使用 2 次。有 E 条边，那么就会有 2E 步来访问邻结点。



按照大 O 计数法（忽略常数），所以图的广度优先搜索有 O(V) 次出队，还有 O(E) 次访问，所以它的效率为 O(V+E)。





## 深度优先搜索（使用栈遍历）







