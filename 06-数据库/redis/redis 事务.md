redis 所有命令都是**原子化**操作，如果说 redis 支持事务，倒不如说 redis 提供了一种把多个指令打包成一个脚本文件批量执行的结果。



## redis 事务介绍

Redis 事务一次可以执行多个命令，有以下两点原则：

- 事务是一个单独的隔离的操作：事务中的所有命令都会**序列化**、按照**顺序地**执行。事务在执行的过程中，不会被其他客户端发过来的命令请求所打断。
- 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。



MULTI、EXEC、DISCARD 和 WATCH 是 redis 事务的基础。

redis 事务从开始到执行一般会经历三个阶段：

- 开始事务 MULTI
- 指令入队
- 执行事务 EXEC



## redis 事务的用法

**1.MULTI 开启事务**

MULTI 命令用于开启一个事务，该方法总是会返回 OK

MULTI 执行完毕后，客户端可以继续向服务器发送任意多条命令，这些命令不会被立即执行，而是放置到一个队列中，只有当 EXEC 命令被调用时，所有队列中的命令才会被执行。

```shell
# 事务开始
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set hello 1
QUEUED
127.0.0.1:6379> set world 2
QUEUED
# 提交事务
127.0.0.1:6379> exec
1) OK
2) OK
```

**2.EXEC 提交事务**

EXEC 命令返回的是一个数组，数组中的每个元素都是执行事务中命令所产生的回复。回复元素的先后顺序和命令发送的先后顺序一致。

事务开启后，如果未提交事务，那么在这期间产生的命令都会返回 QUEUED，这是一个状态回复，只有当 EXEC 命令执行，队列里面的命令才会被执行。



**3.DISCARD 丢弃事务**

如果当我们还未执行 EXEC 命令，可以使用 DISCARD 清空事务队列，放弃执行事务。

```shell
# 开启事务
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set hello1 1
QUEUED
127.0.0.1:6379> set hello2 2
QUEUED
127.0.0.1:6379> discard
OK
# 提交事务返回异常
127.0.0.1:6379> exec
(error) ERR EXEC without MULTI
```

在我们未提交事务之前使用 DISCARD 可以丢弃事务，此时队列中的命令不会再被执行。此时再提交事务，redis 会返回异常。



```shell
127.0.0.1:6379> multi
OK
127.0.0.1:6379> incr a
QUEUED
127.0.0.1:6379> incr b
QUEUED
# redis 检测到指令错误，返回错误，自动取消事务
127.0.0.1:6379> incr a 1
(error) ERR wrong number of arguments for 'incr' command
# 提交 redis 事务
127.0.0.1:6379> exec
(error) EXECABORT Transaction discarded because of previous errors.
```

> 注意：
>
> - 如果是因为我们人为主动丢弃是事务，此时执行提交事务会报错。
>
> - 但是如果是因为我们执行命令的过程中命令错误，比如入参错误，redis 会自动取消事务。
> - 但是**当我们提交了 EXEC 后，队列中的指令开始执行，如果是因为某一条指令执行失败，那么其他的指令将会继续执行，并且不会回滚**。（记住规则，这点比较难模拟）





**4.WATCH监听**

监听某个值的变化，在 redis 的事务中，他提供了一种 check-and-set 的行为。如果监听的某个值在事务过程中发生了变化，那么本次事务将会被直接终止，并且当用户提交 EXEC 指令时，会返回一个 nil 来通知事务失败。

```shell
# 客户端一
127.0.0.1:6379> watch a
OK
127.0.0.1:6379> multi
OK
# 此步骤执行完毕后执行客户端二里面的内容
127.0.0.1:6379> incr a
QUEUED
# 提交事务时，返回了 nil，表明本次事务失败
127.0.0.1:6379> exec
(nil)
```

```shell
# 客户端二
127.0.0.1:6379> incr a
(integer) 4
```

实际 a 的值还是

```shell
127.0.0.1:6379> get a
"4"
```



假设我们现在需要对 a 这个值进行自增操作，在单一客户端的时候，可能表现的没有任何问题。但是在多客户端的情况下就会发生变化，两个客户端同时对 a 这个值进行了 + 1 操作，此时的值变成了 a+1，显然不符合预期。真正的结果应该是 a + 2 才对。

有了 WATCH 之后，这种问题得到了解决

```scala
var a = get a
a = a + 1
set a = $a
```

在执行开始，监听 a

```shell
# 监听 a
watch a
# 获取 a 的值
a = get a
# a 的值进行自增
a = a + 1
# 事务开始
multi
set a $a
exec
```

在 watch 执行完毕之后，exec 执行之前，如果其他的客户端修改了 a 的值，那么当前客户端的事务就会失败。而我们程序应该做的就是不断的重试这个过程，直到不会发生错误为止。

> 这种形式被称为乐观锁，是一种非常强大的锁机制。关于悲观锁和乐观锁，我们单独抽一篇内容来进行讲述。



**5.unwatch取消监听**

取消对某个值的监听操作，这个比较容易理解，就是不再监听某个 key 值的变化。



## Redis 事务问题

> It's important to note that **even when a command fails, all the other commands in the queue are processed** – Redis will *not* stop the processing of commands. [^1]
>
> 这段话是从官网拷贝过来的：
>
> 简单翻译如下：
>
> 这是一个非常重要的笔记：**当队列中有一个命令失败时，队列中的其他命令依然会被执行。- redis 不会阻止剩下的命令执行过程。**

综上：所以虽然 redis 的单条指令是原子性的，但是打包在一个事务里面的 redis 多条指令却并不是原子性的，**redis 不会回滚之前已经执行的操作，也不会阻止剩下的指令执行。**

至于为什么不提供回滚，官网也给了说法

- redis 指令仅仅只是在调用的时候出了语法错误才会失败（并且这种操作一般在入队的时候就能被检测出来）redis 认为这是编程错误，不应该由 redis 来被这个锅。
- redis 是只所以简单轻量快速就是因为它不需要去关心回滚。

一句话来概括就是执行 redis 指令报错了 100% 就是因为你编程的问题，你程序有问题，为啥要我 redis 牺牲性能来帮你背锅，即使我回滚了，你代码错误了，执行还是会报错。（很强势👍，但是好像也没啥毛病）



[^1]: 引用 redis 官网