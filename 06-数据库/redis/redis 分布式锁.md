一般来说，在对数据进行「加锁」时，程序先要通过获取（acquire）锁来得到对数据进行排他性访问的能力，然后才能对数据执行一系列的操作，最后还要释放锁给其他的程序执行。

对于能够被多个线程访问的共享内存来说，这种「先获取锁，然后执行操作，最后释放锁」的动作非常常见。

Redis 中使用了 Watch 命令来构建了一个乐观锁，因为 Watch 命令只会在数据被其他客户端修改后通知执行了 Watch 这个命令的客户端，并不会阻止客户端对数据的修改。



因为 Redis 是单线程（6.0）之前的缘故，所以在 Redis 中分布式锁的操作既不是给同一个进程中的多个线程使用，也不是给同一台机器上的多个进程使用的，而是由不同的机器上的 Redis 客户端进行获取和释放的。所以针对 Redis 的这种情况，我们希望尽最大的可能将锁设置在 Redis 里面。



Redis 提供了一个 SETEX 命令来实现一个基本的加锁功能，但是这个功能并不完整。也不具备一些分布式锁的高级特性。



## 使用 Redis 构建锁

SETNX 命令天生就适合用来实现锁的功能，该命令只会在键不存在的情况下为键设置值，而锁要做的就是生成一个 128 位的 UUID 设置为键的值，并使用这个值来防止锁被其他的进程取得。

如果程序在获取锁的时候失败，那么它将不断地重试，知道成功地取得锁或者超过给定的时限为止。