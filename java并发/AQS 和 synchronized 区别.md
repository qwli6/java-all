

## synchronized



1. synchronized 关键字在底层的 C++ 实现中，存在两个重要的数据结构（集合）：WaitSet，EntryList
2. WaitSet 中存放的是调用了 Object 的 wait 方法的线程对象（被封装成了 C++ 的 Node 对象）
3. EntryList 中存放的是陷入到阻塞状态，需要获取到 Monitor 的哪些线程对象
4. 当一个线程被 notify 后，它就会从 WaitSet 中移动到 EntryList 中
5. 进入到 EntryList 后，该线程依然需要与其他线程争抢 Monitor 对象
6. 如果争抢到，就表示该线程获取到了对象的锁，他就可以以排他的方式执行对应的同步代码



## AQS（）

  1. AQS 中存在两种队列，分别是 Condition 对象的条件队列，以及 AQS 本身的阻塞队列
  2. 这两个队列中的每一个对象都是 Node 实例（里面封装了线程对象）
  3. 当位于 Condition 条件队列中的线程被其他线程 signal 后，该线程就会从条件队列中移动到 AQS 中的阻塞队列中
  4. 位于 AQS 阻塞队列中的 Node 对象本质上都是由一个双向链表来实现的
  5. 在获取 AQS 锁时，这些进入到阻塞队列中的线程都会按到在队列中的排序先后尝试获取
  6. 当 AQS 阻塞队列中的线程获取到锁后，就表示该线程已经可以正常执行了
  7. 陷入到阻塞状态的线程，依然需要进入到操作系统的内核态，进入阻塞（park 方法实现）