

缓存是我们在应用开发中不可或缺的一个中间件，利用缓存的常规处理流程如下

![image-20200825211015252](/Users/liqiwen/Library/Application Support/typora-user-images/image-20200825211015252.png)

当用户发起请求时

- 先查询缓存中是否存在数据
  - 存在直接返回给用户
  - 不存在，从 db 中获取
    - 获取到数据返返回给用户
    - 同时设置数据到缓存中



正常的操作是这样没错，但是没有考虑边界（异常）情况。



## 缓存雪崩

什么是缓存雪崩？

非常短的时间间隔内，缓存大批量失效，导致非常多的请求无法从缓存中获取数据转而查询数据库，将查询到的数据回写到缓存中。因为大批量的查询数据库，这往往不是数据库所能承受的请求数据量，从而压垮数据库，导致服务宕机。

一般在缓存服务器重启或者大量缓存在某一个时间段内同时失效，这样在失效的时候，会给后端系统（DB）带来巨大的压力。



> key 在系统中存在，只是大量的 key 在同一时间段内集体失效



解决方案:

- 设置多级缓存，比如设置两层缓存，C1 C2， C1 的失效时间短，在最上层，C2 的失效时间长，在 C1 下层。
- 优化缓存失效策略



## 缓存穿透

什么是缓存穿透？

缓存穿透是指没有从缓存中命中数据，导致大批量的请求进入数据库，导致数据库宕机。

比如我们将用户表的主键 id 设置成自增长，当用户访问一个 id < 0 的请求进来，很显然缓存中不存在这样的 id，那么就会导致所有数据直接请求数据库，导致数据库宕机。



> key 在缓存中不存在，直接访问数据库
>
> 随机访问 （-10000， 0）之间的任意一个缓存数据，请求都将会直接进入后端系统（DB）

解决方案：

- 添加布隆过滤器，过滤掉不可能有缓存值请求
- 业务校验，比如当发现请求 id < 0 的时候直接返回数据不存在
- 缓存一个空的数据，设置合适的过期时间



## 缓存击穿

什么是缓存击穿？

同一时间大量请求同一数据，此时缓存刚好失效。比如10万人同时获取



解决方案：

- 热点数据不设置过期时间



> 大量的请求同时访问某一个数据，而这个缓存 key 刚好失效，导致并发请求全部访问后端系统





## 三者之间的区别

缓存雪崩: 缓存中存在 key，但是大批量的 key 在同一个时间段集体失效

缓存穿透: 缓存中不存在 key，大批量的请求访问某一些不存在的 key，导致请求直接进入 DB

缓存击穿: 缓存中存在 key，但是这个 key 在某个时间点恰好失效，并发请求同时访问这一个 key，导致直接进入 DB